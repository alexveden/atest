
#include "atest.h"
//
// IMPORTANT: if wee need to wrap selective public functions from lib, we need to include "lib.h" instead of "lib.c"
//      then we need to build Makefile "gcc -Wl,--wrap=some_func,--wrap=other_func test_code.c lib.c"    <-- include lib.c and dependencies!    
//      to get all symbols do `nm <exec_path>`
//
#include "../src/testlib.h"
#include <stdio.h>
#include "fff.h"

DEFINE_FFF_GLOBALS;

// gcc --wrap=putc  also works with fff.h!
// HACK: original testlib.c code uses putchar() but real after compilation uses putc()
// see `nm exec_name` to figure out what read symbols are in real use
FAKE_VALUE_FUNC(int, __wrap_putc, int);
FAKE_VALUE_FUNC(int, __wrap_add2, int);

/* Initialializers called for every test */
ATEST_SETUP_F(void)
{
    return NULL;   // if no shutdown logic needed
}

/*
 * static func wrapping is impossible! because they are not included as symbols
 *
void __wrap_static_puts_func_mock()
{
    printf("__wrap_static_puts_func_mock\n");
}
*/

int __wrap_add(int a, int b)
{
    return (a + b) * 10; 
    // Original is also available
    //return __real_add(a, b);
}

/*  Wrapping system functions: stdio::puts
 *
 * Wrapping system call is BAD practice, unpredictable sideeffects possible! 
 * It's better to create a dedicated function-wrapper for a lib, and make wrappings for it.
 *
 */
int __wrap_puts(const char * c){
    // gcc ... -Wl,--wrap=abort,--wrap=fun2
    printf("puts() wrapper function wrapper called: %s\n", c);
    // Calling original function!
    
    //printf("__real_puts: ");
    //return __real_puts(c);
    return 0;
}

ATEST_F(assert_call_with_abort)
{
    // this function calls abort() which has to be mocked!
    //     with gcc --wrap
    // Should print something like: puts() wrapper function wrapper called: public_abort_func_mock
    public_puts_func_mock();    
    return NULL; // Every ATEST_F() must return NULL to succeed!
}

ATEST_F(assert_static_func_selective_mock)
{
    //     with gcc --wrap=static_puts_func_mock
    putchar_func(1);    
    atassert(__wrap_putc_fake.call_count == 1)
    return NULL; // Every ATEST_F() must return NULL to succeed!
}

ATEST_F(wrap_selective_func_from_lib)
{
    //     with gcc --wrap=static_puts_func_mock
    atassert(add(2, 2) == 40);
    return NULL; // Every ATEST_F() must return NULL to succeed!
}

ATEST_F(fff_selective_func_from_lib)
{
    __wrap_add2_fake.return_val = 1000; 
    //     with gcc --wrap=add2
    atassert(add2(2) == 1000);
    return NULL; // Every ATEST_F() must return NULL to succeed!
}

int main(int argc, char *argv[])
{
    //FILE * f = fopen("test.log", "w");
    //__ATestContext.out_stream = f;
    __ATestContext.verbosity = 3;

    ATEST_PARSE_MAINARGS(argc, argv);
    ATEST_PRINT_HEAD();

    // <ATEST_RUNS>   -- do not replace to make 'atest' utility automatic test updates
    ATEST_RUN(assert_call_with_abort);
    ATEST_RUN(assert_static_func_selective_mock);
    ATEST_RUN(wrap_selective_func_from_lib);
    ATEST_RUN(fff_selective_func_from_lib);
    // ^^^^ this block is automatically generated by 'atest' utility

    ATEST_PRINT_FOOTER();
    //fclose(f);
    
    return ATEST_EXITCODE();
}
